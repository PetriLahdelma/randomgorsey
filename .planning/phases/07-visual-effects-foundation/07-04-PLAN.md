---
phase: 07-visual-effects-foundation
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/effects/Scene3D.tsx
  - src/components/effects/ParticleField.tsx
  - src/components/effects/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "User on high-powered device sees WebGL particle effects"
    - "User on low-powered device sees graceful fallback (no effects)"
    - "User with reduced motion sees no particle animation"
    - "Particle count scales with device capability (tier 1: 250, tier 2: 500, tier 3: 1000)"
  artifacts:
    - path: "src/components/effects/Scene3D.tsx"
      provides: "R3F Canvas wrapper with performance controls"
      exports: ["Scene3D"]
      min_lines: 40
    - path: "src/components/effects/ParticleField.tsx"
      provides: "Instanced particle system"
      exports: ["ParticleField"]
      min_lines: 60
    - path: "package.json"
      provides: "R3F dependencies installed"
      contains: "@react-three/fiber"
  key_links:
    - from: "src/components/effects/Scene3D.tsx"
      to: "src/lib/performance/context.tsx"
      via: "usePerformance hook"
      pattern: "usePerformance"
    - from: "src/components/effects/ParticleField.tsx"
      to: "src/components/effects/Scene3D.tsx"
      via: "renders inside Scene3D canvas"
      pattern: "Scene3D"
---

<objective>
Create React Three Fiber infrastructure with a performance-tiered particle system that scales based on GPU capability.

Purpose: Enable WebGL effects for high-powered devices while providing graceful fallbacks for lower-tier devices.
Output: Scene3D wrapper component and ParticleField particle system with automatic performance scaling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-visual-effects-foundation/07-RESEARCH.md
@.planning/phases/07-visual-effects-foundation/07-01-SUMMARY.md
@src/lib/performance/context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Three Fiber dependencies</name>
  <files>
    - package.json
  </files>
  <action>
Install R3F and supporting libraries:
```bash
npm install @react-three/fiber @react-three/drei three
npm install -D @types/three
```

Note: We're NOT installing @react-three/postprocessing yet - keep scope minimal. Postprocessing can be added later if needed.

Verify installation:
- `npm ls @react-three/fiber` shows version installed
- `npm ls three` shows version installed
  </action>
  <verify>
    - `npm ls @react-three/fiber` shows package
    - `npm ls @react-three/drei` shows package
    - `npm ls three` shows package
  </verify>
  <done>React Three Fiber and dependencies are installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Scene3D wrapper component</name>
  <files>
    - src/components/effects/Scene3D.tsx
  </files>
  <action>
Create `src/components/effects/Scene3D.tsx`:

Props interface:
```typescript
interface Scene3DProps {
  /** Scene contents (R3F components) */
  children: React.ReactNode;
  /** Additional CSS classes for container */
  className?: string;
  /** Whether scene is absolute positioned overlay */
  overlay?: boolean;
  /** Initial DPR (device pixel ratio), auto-adjusts based on performance */
  dpr?: number;
}
```

Implementation:
- Import Canvas from '@react-three/fiber'
- Import usePerformance from '@/lib/performance'
- Import cn from '@/lib/utils'
- Check canWebGL and tier:
  - If !canWebGL or tier === 0: return null (no 3D rendering)
  - If tier 1: use dpr 1, no antialiasing
  - If tier 2: use dpr 1.5, antialiasing on
  - If tier 3: use dpr 2, antialiasing on
- Use frameloop="demand" for on-demand rendering (saves battery)
- Wrap in div with appropriate positioning classes

Pattern:
```typescript
import { Canvas } from '@react-three/fiber';
import { usePerformance } from '@/lib/performance';
import { cn } from '@/lib/utils';

export interface Scene3DProps {
  children: React.ReactNode;
  className?: string;
  overlay?: boolean;
  dpr?: number;
}

export const Scene3D: React.FC<Scene3DProps> = ({
  children,
  className,
  overlay = false,
  dpr: initialDpr,
}) => {
  const { tier, canWebGL } = usePerformance();

  // No WebGL support or tier 0: skip rendering
  if (!canWebGL || tier === 0) {
    return null;
  }

  // Scale DPR and quality based on tier
  const dpr = initialDpr ?? (tier >= 3 ? 2 : tier >= 2 ? 1.5 : 1);
  const antialias = tier >= 2;

  return (
    <div
      className={cn(
        overlay ? 'absolute inset-0 -z-10' : 'relative h-full w-full',
        className
      )}
    >
      <Canvas
        frameloop="demand"
        dpr={dpr}
        gl={{ antialias }}
      >
        {children}
      </Canvas>
    </div>
  );
};

export default Scene3D;
```
  </action>
  <verify>
    - `npx tsc --noEmit src/components/effects/Scene3D.tsx` compiles without errors
    - File exists at src/components/effects/Scene3D.tsx
  </verify>
  <done>Scene3D wrapper component exists with tier-based quality settings</done>
</task>

<task type="auto">
  <name>Task 3: Create ParticleField component</name>
  <files>
    - src/components/effects/ParticleField.tsx
    - src/components/effects/index.ts
  </files>
  <action>
1. Create `src/components/effects/ParticleField.tsx`:

Props interface:
```typescript
interface ParticleFieldProps {
  /** Base particle count (scales with tier) */
  count?: number;
  /** Particle color */
  color?: string;
  /** Spread area size */
  spread?: number;
  /** Particle size */
  size?: number;
}
```

Implementation:
- Import Instances, Instance from '@react-three/drei'
- Import useFrame from '@react-three/fiber'
- Import usePerformance from '@/lib/performance'
- Use useMemo to generate particle positions (random distribution in 3D space)
- Scale particle count based on tier:
  - Tier 1: count / 4
  - Tier 2: count / 2
  - Tier 3: full count
- Use drei Instances for GPU-efficient instanced rendering
- Optional: gentle floating animation using useFrame (mutate refs, not state)

Pattern:
```typescript
import { useMemo, useRef } from 'react';
import { Instances, Instance } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { usePerformance } from '@/lib/performance';
import * as THREE from 'three';

export interface ParticleFieldProps {
  count?: number;
  color?: string;
  spread?: number;
  size?: number;
}

export const ParticleField: React.FC<ParticleFieldProps> = ({
  count = 1000,
  color = '#ffffff',
  spread = 10,
  size = 0.05,
}) => {
  const { tier, isReducedMotion } = usePerformance();
  const groupRef = useRef<THREE.Group>(null);

  // Scale count based on tier
  const actualCount = tier >= 3 ? count : tier >= 2 ? count / 2 : count / 4;

  // Generate particle positions once
  const particles = useMemo(() => {
    return Array.from({ length: actualCount }, () => ({
      position: [
        (Math.random() - 0.5) * spread,
        (Math.random() - 0.5) * spread,
        (Math.random() - 0.5) * spread,
      ] as [number, number, number],
      scale: Math.random() * 0.5 + 0.5,
    }));
  }, [actualCount, spread]);

  // Gentle rotation animation (only if motion allowed)
  useFrame((state, delta) => {
    if (groupRef.current && !isReducedMotion) {
      groupRef.current.rotation.y += delta * 0.05;
    }
  });

  return (
    <group ref={groupRef}>
      <Instances limit={actualCount}>
        <sphereGeometry args={[size, 8, 8]} />
        <meshBasicMaterial color={color} />
        {particles.map((p, i) => (
          <Instance key={i} position={p.position} scale={p.scale} />
        ))}
      </Instances>
    </group>
  );
};

export default ParticleField;
```

2. Update `src/components/effects/index.ts`:
```typescript
export { VideoBackground } from './VideoBackground';
export type { VideoBackgroundProps } from './VideoBackground';

export { HeroImage } from './HeroImage';
export type { HeroImageProps } from './HeroImage';

export { Scene3D } from './Scene3D';
export type { Scene3DProps } from './Scene3D';

export { ParticleField } from './ParticleField';
export type { ParticleFieldProps } from './ParticleField';
```
  </action>
  <verify>
    - `npx tsc --noEmit src/components/effects/ParticleField.tsx` compiles without errors
    - `npm run build` completes without errors
  </verify>
  <done>ParticleField component uses instanced rendering with tier-scaled particle count</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Verify Scene3D and ParticleField are importable from '@/components/effects'
3. R3F packages are installed and TypeScript types work
</verification>

<success_criteria>
- React Three Fiber, drei, and three are installed
- Scene3D returns null for tier 0 or no WebGL support
- Scene3D scales DPR and antialiasing based on tier
- ParticleField scales particle count: tier 1 = 250, tier 2 = 500, tier 3 = 1000
- ParticleField respects reduced motion (no animation)
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-visual-effects-foundation/07-04-SUMMARY.md`
</output>
