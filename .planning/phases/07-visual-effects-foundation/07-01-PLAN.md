---
phase: 07-visual-effects-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/performance/context.tsx
  - src/lib/performance/gpu-tier.ts
  - src/lib/performance/index.ts
  - src/lib/motion/AnimationProvider.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "User on low-power device sees optimized experience (tier 0-1)"
    - "User on high-power device gets full visual effects (tier 3)"
    - "User with prefers-reduced-motion gets tier 0 regardless of GPU"
  artifacts:
    - path: "src/lib/performance/context.tsx"
      provides: "PerformanceProvider and usePerformance hook"
      exports: ["PerformanceProvider", "usePerformance"]
    - path: "src/lib/performance/gpu-tier.ts"
      provides: "GPU tier detection configuration"
      exports: ["getPerformanceTier", "PerformanceContext"]
    - path: "src/lib/performance/index.ts"
      provides: "Public API barrel export"
      exports: ["PerformanceProvider", "usePerformance"]
  key_links:
    - from: "src/lib/motion/AnimationProvider.tsx"
      to: "src/lib/performance/context.tsx"
      via: "wraps PerformanceProvider"
      pattern: "PerformanceProvider"
---

<objective>
Create GPU tier detection infrastructure that classifies devices into performance tiers (0-3) and provides this context to all visual effects components.

Purpose: Enable performance-tiered rendering - static images for tier 0, optimized video for tier 1-2, full WebGL for tier 3.
Output: PerformanceProvider wrapping the app, usePerformance hook for components to query device capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-visual-effects-foundation/07-RESEARCH.md
@src/lib/motion/AnimationProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install detect-gpu and create GPU tier module</name>
  <files>
    - package.json
    - src/lib/performance/gpu-tier.ts
  </files>
  <action>
1. Install detect-gpu:
   ```bash
   npm install detect-gpu
   ```

2. Create `src/lib/performance/gpu-tier.ts`:
   - Define PerformanceContext interface with: tier (0-3), isMobile, isReducedMotion, canWebGL
   - Export getPerformanceTier async function that calls detect-gpu's getGPUTier()
   - Map TierResult to PerformanceContext
   - Handle reduced motion preference (force tier 0 if enabled)
   - Default safe values: tier 1, isMobile false, canWebGL true

Pattern from research:
```typescript
import { getGPUTier, TierResult } from 'detect-gpu';

export interface PerformanceContext {
  tier: number;           // 0-3
  isMobile: boolean;
  isReducedMotion: boolean;
  canWebGL: boolean;
}

export async function getPerformanceTier(): Promise<PerformanceContext> {
  const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  try {
    const result: TierResult = await getGPUTier();
    return {
      tier: reducedMotion ? 0 : result.tier,
      isMobile: result.isMobile ?? false,
      isReducedMotion: reducedMotion,
      canWebGL: result.tier > 0,
    };
  } catch {
    return {
      tier: reducedMotion ? 0 : 1,
      isMobile: false,
      isReducedMotion: reducedMotion,
      canWebGL: true,
    };
  }
}
```
  </action>
  <verify>
    - `npm ls detect-gpu` shows package installed
    - `npx tsc --noEmit src/lib/performance/gpu-tier.ts` compiles without errors
  </verify>
  <done>GPU tier detection module exists with typed interface and async detection function</done>
</task>

<task type="auto">
  <name>Task 2: Create PerformanceProvider and usePerformance hook</name>
  <files>
    - src/lib/performance/context.tsx
    - src/lib/performance/index.ts
  </files>
  <action>
1. Create `src/lib/performance/context.tsx`:
   - Import PerformanceContext and getPerformanceTier from gpu-tier
   - Create React context with null default
   - Create PerformanceProvider that:
     - Uses useState with safe default (tier 1)
     - Calls getPerformanceTier() in useEffect on mount
     - Sets state with detected values
   - Create usePerformance hook that:
     - Uses useContext to get performance context
     - Throws if used outside provider (clear error message)
     - Returns PerformanceContext object

2. Create `src/lib/performance/index.ts`:
   - Re-export PerformanceProvider from context
   - Re-export usePerformance from context
   - Re-export PerformanceContext type from gpu-tier

Pattern:
```typescript
import React, { createContext, useContext, useEffect, useState } from 'react';
import { PerformanceContext, getPerformanceTier } from './gpu-tier';

const PerfCtx = createContext<PerformanceContext | null>(null);

export const PerformanceProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [perf, setPerf] = useState<PerformanceContext>({
    tier: 1,
    isMobile: false,
    isReducedMotion: false,
    canWebGL: true,
  });

  useEffect(() => {
    getPerformanceTier().then(setPerf);
  }, []);

  return <PerfCtx.Provider value={perf}>{children}</PerfCtx.Provider>;
};

export const usePerformance = (): PerformanceContext => {
  const ctx = useContext(PerfCtx);
  if (!ctx) {
    throw new Error('usePerformance must be used within PerformanceProvider');
  }
  return ctx;
};
```
  </action>
  <verify>
    - `npx tsc --noEmit src/lib/performance/context.tsx` compiles without errors
    - `npx tsc --noEmit src/lib/performance/index.ts` compiles without errors
  </verify>
  <done>PerformanceProvider and usePerformance hook are exported from src/lib/performance</done>
</task>

<task type="auto">
  <name>Task 3: Integrate PerformanceProvider into AnimationProvider</name>
  <files>
    - src/lib/motion/AnimationProvider.tsx
  </files>
  <action>
1. Update `src/lib/motion/AnimationProvider.tsx`:
   - Import PerformanceProvider from '@/lib/performance'
   - Wrap PerformanceProvider around the existing provider tree
   - Keep LazyMotion and MotionConfig as they are
   - PerformanceProvider should be outermost (performance detection doesn't depend on motion)

Updated structure:
```typescript
import { PerformanceProvider } from '@/lib/performance';

export const AnimationProvider: React.FC<AnimationProviderProps> = ({
  children,
  reducedMotion = 'user',
}) => {
  return (
    <PerformanceProvider>
      <LazyMotion features={domAnimation}>
        <MotionConfig reducedMotion={reducedMotion}>
          <LenisProvider>{children}</LenisProvider>
        </MotionConfig>
      </LazyMotion>
    </PerformanceProvider>
  );
};
```

2. Verify build succeeds with provider integrated.
  </action>
  <verify>
    - `npm run build` completes without errors
    - Browser console shows no errors on page load
  </verify>
  <done>PerformanceProvider wraps AnimationProvider, app builds and runs</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Start dev server with `npm run dev`
3. Open browser console - no errors about PerformanceProvider
4. The detect-gpu package should log tier info in development mode
</verification>

<success_criteria>
- detect-gpu package is installed
- PerformanceProvider is part of app provider tree
- usePerformance hook is available for components
- Build passes with no TypeScript errors
- App loads without runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-visual-effects-foundation/07-01-SUMMARY.md`
</output>
